#pragma once

#include <scenesrg_all.srgi>
#include <viewsrg_all.srgi>
#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/InstancedTransforms.azsli>
#include <Atom/Features/SrgSemantics.azsli>

ShaderResourceGroup WaterDepthDrawSrg : SRG_PerDraw
{
}

ShaderResourceGroup WaterColorSrg : SRG_PerMaterial
{
    float3 m_waterColor;
    float3 m_waterColor2;
    float3 m_foamColor;
    float m_waterAlpha;
    float m_waveSpeed;
    float m_waveScale;
    float m_waveAmplitude;
    float m_distortionSpeed;
    float2 m_tile;
}

struct VSIn
{
    float3 m_position : POSITION;
    float2 m_uv : UV0;
};

struct VSOut
{
    float4 m_position : SV_Position;
};

// Constants
static const float M_2PI = 6.283185307;
static const float M_6PI = 18.84955592;

// Wave displacement function for depth (simplified version)
float3 waveDisplacement(float2 uv, float time) 
{
    float2 uv_scaled = uv * WaterColorSrg::m_waveScale;
    
    // Create two directional waves at slightly different angles
    float d1 = fmod(uv_scaled.x + uv_scaled.y, M_2PI);
    float d2 = fmod((uv_scaled.x + uv_scaled.y + 0.25) * 1.3, M_6PI);
    d1 = time * 0.07 + d1;
    d2 = time * 0.5 + d2;
    
    float2 dist = float2(
        sin(d1) * 0.15 + sin(d2) * 0.05,
        cos(d1) * 0.15 + cos(d2) * 0.05
    );
    
    // Apply amplitude control to horizontal movement (X, Z)
    float horizontalX = dist.y * WaterColorSrg::m_waveAmplitude;
    float horizontalZ = dist.x * WaterColorSrg::m_waveAmplitude;
    
    return float3(horizontalX, 0.0, horizontalZ);
}

VSOut MainVS(VSIn IN, uint instanceId : SV_InstanceID)
{
    VSOut OUT;
    
    // Get time for animation
    float time = SceneSrg::m_time * WaterColorSrg::m_waveSpeed;
    
    // Apply wave displacement
    float3 displacement = waveDisplacement(IN.m_uv, time);
    float3 displacedPosition = IN.m_position + displacement;
    
    float4x4 objectToWorld = GetObjectToWorldMatrix(instanceId);
    float3 worldPosition = mul(objectToWorld, float4(displacedPosition, 1)).xyz;
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(worldPosition, 1.0));
    
    return OUT;
}
