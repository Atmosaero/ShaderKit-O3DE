#pragma once

#include <scenesrg_all.srgi>
#include <viewsrg_all.srgi>
#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/InstancedTransforms.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassOutput.azsli>
#include <Atom/Features/SrgSemantics.azsli>

ShaderResourceGroup WireframeDrawSrg : SRG_PerDraw
{
}

ShaderResourceGroup WireframeSrg : SRG_PerMaterial
{
    float3 m_gridColor;
    float m_gridThickness;
    float m_glowStrength;
}

struct VertexShaderInput
{
    float3 m_position : POSITION;
    float3 m_normal : NORMAL;
};

struct VertexShaderOutput
{
    float4 m_position : SV_Position;
    float3 m_worldPos : TEXCOORD0;
    float3 m_normal : TEXCOORD1;
};

struct GeometryOutput
{
    float4 m_position : SV_Position;
    float3 m_worldPos : TEXCOORD0;
    float3 m_normal : TEXCOORD1;
    float3 m_barycentric : TEXCOORD2;
};

VertexShaderOutput MainVS(VertexShaderInput IN, uint instanceId : SV_InstanceID)
{
    VertexShaderOutput OUT;
    
    float4x4 objectToWorld = GetObjectToWorldMatrix(instanceId);
    float4 worldPosition4 = mul(objectToWorld, float4(IN.m_position, 1.0));
    float3 worldPosition = worldPosition4.xyz;
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, worldPosition4);
    OUT.m_worldPos = worldPosition;
    OUT.m_normal = mul(GetObjectToWorldMatrixInverseTranspose(instanceId), IN.m_normal);
    
    return OUT;
}

[maxvertexcount(3)]
void MainGS(triangle VertexShaderOutput IN[3], inout TriangleStream<GeometryOutput> triStream)
{
    const float3 barycentrics[3] = {
        float3(1.0, 0.0, 0.0),
        float3(0.0, 1.0, 0.0),
        float3(0.0, 0.0, 1.0)
    };

    [unroll]
    for (uint i = 0; i < 3; ++i)
    {
        GeometryOutput OUT;
        OUT.m_position = IN[i].m_position;
        OUT.m_worldPos = IN[i].m_worldPos;
        OUT.m_normal = IN[i].m_normal;
        OUT.m_barycentric = barycentrics[i];
        triStream.Append(OUT);
    }
}

ForwardPassOutput MainPS(GeometryOutput IN)
{
    ForwardPassOutput OUT;
    
    float3 barycentric = saturate(IN.m_barycentric);
    float edgeValue = min(min(barycentric.x, barycentric.y), barycentric.z);
    float edgeWidth = WireframeSrg::m_gridThickness;
    float edgeDerivative = fwidth(edgeValue);
    float edgeMask = saturate((edgeWidth - edgeValue) / max(edgeDerivative, 1e-4));
    edgeMask = pow(edgeMask, 1.0 + WireframeSrg::m_glowStrength * 0.5);

    float alpha = saturate(edgeMask);
    clip(alpha - 1e-4);
    
    float3 edgeColor = WireframeSrg::m_gridColor;
    float emissiveFactor = WireframeSrg::m_glowStrength * alpha;
    float3 emission = edgeColor * emissiveFactor;
    
    OUT.m_diffuseColor = float4(edgeColor, alpha);
    OUT.m_specularColor = float4(emission, alpha);
    
    return OUT;
} 
